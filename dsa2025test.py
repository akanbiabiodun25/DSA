# -*- coding: utf-8 -*-
"""DSA2025Test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16tolr7J_fHJcMkDxYVI-MGNK99hTVX3I
"""

# !pip install otter-grader

# from google.colab import drive
# drive.mount('/content/drive')

# !cd /content/drive/MyDrive/DSA25Test

# !mkdir tests

# from google.colab import files
# uploaded = files.upload()

# !mv DSA2025Test.ipynb tests/

# Initialize Otter
#import otter
#grader = otter.Notebook("DSA2025Test.ipynb")
import otter
# grader = otter.Notebook("/content/drive/MyDrive/DSA25Test/DSA2025Test.ipynb")
grader = otter.Notebook(tests_dir="/test") #"test/DSA2025Test.ipynb" #, nb_path="test"

"""# DSA 2025 Summer School Admittance Check

Thanks for your interest in attending DSA 2025 Ibadan, Nigeria. To attend the summer school you have to have some level of basic Python proficiency. Completing the following notebook should ensure you have the right kind of background to benefit maximally from the Summer School. See you in Ibadan!

## Instructions
1. Complete each function according to the provided specifications
2. Run all cells to verify your solutions
3. All tests must pass to generate a submission
4. Save your work before submitting
"""

# Run these once ... To be on a safe side
# !pip install nose
# !pip install otter-grader
import IPython
from IPython import get_ipython
# Import the good stuff
import pandas as pd
import numpy as np
import math
from nose.tools import assert_equal
import otter
from collections import Counter

grader = otter.Notebook()

"""<!-- BEGIN QUESTION -->

**Question 1:**
Write a Python function to return a tuple of even and odd numbers

1.   List item
2.   List item

given an integer input.</br>
Example: For input 10, the output should be ([2, 4, 6, 8, 10], [1, 3, 5, 7, 9]).
"""

# !mv q1.py tests/

def even_odd_numbers(n):
    """
    Returns a tuple of even and odd numbers up to n.

    Args:
        n (int): The upper limit.

    Returns:
        tuple: A tuple of two lists: (evens, odds).
    """

    evens = []
    odds = []
    for i in range(1, n + 1):
        if i % 2 == 0:
            evens.append(i)
        else:
            odds.append(i)
    return (evens, odds)

grader.check("q1")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 2: Create a dictionary to store the frequency of each word in the paragraph provided.**</br>
Example: For the paragraph "Data science is fun. Data science is useful.", the output should be {'Data': 2, 'science': 2, 'is': 2, 'fun': 1, 'useful': 1}.
"""

# !mv q2.py tests/

def word_frequency(paragraph):
    """
    Returns a dictionary of word frequencies in a paragraph.

    Args:
        paragraph (str): The input paragraph.

    Returns:
        dict: A dictionary with words as keys and their frequencies as values.
    """

    words = paragraph.split()  # Split the paragraph into individual words
    word_counts = {}  # Initialize an empty dictionary to store word frequencies

    for word in words:
        word = word.strip('.,!?"').capitalize()  # Remove punctuation and capitalize
        if word:  # Check if the word is not empty after removing punctuation
            word_counts[word] = word_counts.get(word, 0) + 1

    return word_counts  # Return the dictionary of word frequencies

grader.check("q2")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 3: Extract the values from the dictionary above into a list and sort them in descending order.**</br>
Example: For the dictionary {'a': 3, 'b': 1, 'c': 2}, the output should be [3, 2, 1]
"""

# !mv q3.py tests/

def extract_and_sort_values(dictionary):
    """
    Extracts and sorts dictionary values in descending order.

    Args:
        dictionary (dict): The input dictionary.

    Returns:
        list: A list of sorted values in descending order.
    """
    values = list(dictionary.values())  # Extract values into a list
    values.sort(reverse=True)  # Sort in descending order
    return values  # Return the sorted list

grader.check("q3")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 4: Merge the two lists (from Questions 3 and 4) into a dictionary where the keys are the sorted keys and the values are the sorted values.**</br>
Example: For lists ['a', 'b', 'c'] and [3, 2, 1], the output should be {'a': 3, 'b': 2, 'c': 1}
"""

# !mv q4.py tests/

def merge_lists_to_dict(keys, values):
    """
    Merges two lists into a dictionary.

    Args:
        keys (list): List of keys.
        values (list): List of values.

    Returns:
        dict: A dictionary with keys and values paired.
    """
    merged_dict = dict(zip(keys, values))  # Merge using zip and dict
    return merged_dict  # Return the merged dictionary

grader.check("q4")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 5:Write a function least_common_multiple that takes two inputs a and b and returns the least common multiple of the two numbers.**</br>
Example: For input (4, 6), the output should be 12
"""

# !mv q5.py tests/

def least_common_multiple(a, b):
    """
    Returns the least common multiple of two numbers.

    Args:
        a (int): First number.
        b (int): Second number.

    Returns:
        int: The LCM of a and b.
    """
    return abs(a*b) // math.gcd(a, b)  # Calculate and return the LCM

grader.check("q5")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 6:Write a function get_nearest_farthest that takes in a point of interest (x, y) and a list of points [(x1, y1), (x2, y2), ...] and returns the indices of the nearest and farthest points from the point of interest.** </br>
Example: For pt = (0, 0) and points = [(1, 1), (3, 3), (-1, -1)], the output should be (0, 1)
"""

# !mv q6.py tests/

def get_nearest_farthest(pt, points):
    """
    Returns the in dices of the nearest and farthest points from a point of interest.

    Args:
        pt (tuple): The point of interest (x, y).
        points (list): List of points [(x1, y1), (x2, y2), ...].

    Returns:
        tuple: Indices of the nearest and farthest points.
    """
    distances = [(i, (x - pt[0])**2 + (y - pt[1])**2) for i, (x, y) in enumerate(points)]

    nearest_index = min(distances, key=lambda d: d[1])[0]
    farthest_index = max(distances, key=lambda d: d[1])[0]

    return nearest_index, farthest_index

grader.check("q6")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 7:Write a function filter_divisible to return a list of numbers between 0 and a number N that are not perfectly divisible by q.** </br>

> Hint: If N is negative, use N = 20.

Example: For N = 10 and q = 2, the output should be [1, 3, 5, 7, 9]
"""

# !mv q7.py tests

def filter_divisible(N, q):
    """
    Returns a list of numbers between 0 and N that are not divisible by q.

    Args:
        N (int): The upper limit.
        q (int): The divisor.

    Returns:
        list: A list of non-divisible numbers.
    """
    if N < 0:
        N = 20  # Use N = 20 if N is negative

    return [i for i in range(N) if i % q != 0]

grader.check("q7")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 8: Write a function flatten_and_unique that takes in a list of lists and outputs a sorted list of unique elements from all sublists.**
"""

# !mv q8.py tests

def flatten_and_unique(list_of_lists):
    """
    Flattens a list of lists and returns a sorted list of unique elements.

    Args:
        list_of_lists (list): A list of lists.

    Returns:
        list: A sorted list of unique elements.
    """
    unique_elements = set()  # Use a set to store unique elements

    for sublist in list_of_lists:
        unique_elements.update(sublist)  # Add elements from each sublist

    return sorted(unique_elements)  # Return a sorted list of unique elements

grader.check("q8")

"""<!-- END QUESTION -->

**The Extra Mile!**

Download the dataset Nigeria Food Prices (9.9M)

> https://data.humdata.org/dataset/wfp-food-prices-for-nigeria

<!-- BEGIN QUESTION -->

**Question 9: Create a new column date_new from the date column, converting it to a datetime format.**
"""

# !mv q9.py tests

import pandas as pd

# Load the dataset
file_path = 'wfp_food_prices_nga.csv'  # Replace with the actual file path
df = pd.read_csv(file_path,skiprows=[1])
df = df.drop(index=2)
df = df.reset_index(drop=True)

# Display the first few rows of the dataset
print("First 5 rows of the dataset:")
print(df.head())

def create_date_new(df):
    """
    Creates a new column `date_new` from the `date` column, converting it to a datetime format.

    Args:
        df (pd.DataFrame): The input dataframe.

    Returns:
        pd.DataFrame: The dataframe with the new `date_new` column.
    """
    df = df.copy()  # Avoid modifying the original dataframe
    df["date_new"] = pd.to_datetime(df["date"], errors="coerce")  # Convert to datetime
    return df

grader.check("q9")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 10:Split the dataframe into two separate dataframes based on the category column: one for cereals and tubers and another for pulses and nuts**
"""

# !mv q10.py tests

def split_dataframes(df):
    """
    Splits the dataframe into two separate dataframes based on the `category` column.

    Args:
        df (pd.DataFrame): The input dataframe.

    Returns:
        tuple: A tuple of two dataframes: (cereals_df, pulses_df).
    """
    df = df.copy()  # Avoid modifying the original dataframe

    cereals_df = df[df["category"].str.lower() == "cereals and tubers"].reset_index(drop=True)
    pulses_df = df[df["category"].str.lower() == "pulses and nuts"].reset_index(drop=True)

    return cereals_df, pulses_df

grader.check("q10")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 11:Calculate the mean, median, and mode of the price and usdprice columns for each category**
"""

# !mv q11.py tests

def calculate_price_stats(df):
    """
    Calculates the mean, median, and mode of the `price` and `usdprice` columns for each `category`.

    Args:
        df (pd.DataFrame): The input dataframe.

    Returns:
        tuple: A tuple of two dataframes: (price_stats, usdprice_stats).
    """
    df = df.copy()  # Avoid modifying the original dataframe

    # Group by category and calculate mean & median
    price_stats = df.groupby("category")["price"].agg(["mean", "median"]).reset_index()
    usdprice_stats = df.groupby("category")["usdprice"].agg(["mean", "median"]).reset_index()

    # Calculate mode separately (mode can return multiple values, so take the first one)
    price_mode = df.groupby("category")["price"].agg(lambda x: x.mode().iloc[0] if not x.mode().empty else None).reset_index()
    usdprice_mode = df.groupby("category")["usdprice"].agg(lambda x: x.mode().iloc[0] if not x.mode().empty else None).reset_index()

    # Merge mode values into the existing stats
    price_stats = price_stats.merge(price_mode, on="category").rename(columns={"price": "mode"})
    usdprice_stats = usdprice_stats.merge(usdprice_mode, on="category").rename(columns={"price": "mode"})

    return price_stats, usdprice_stats

grader.check("q11")

price_stats, usdprice_stats = calculate_price_stats(df)
print("Price Stats:\n", price_stats)
print("\nUSD Price Stats:\n", usdprice_stats)

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 12:Merge the two dataframes (from Question 11) back into one dataframe and save it as `merged_data.csv`.**
"""

# !mv q12.py tests

def merge_dataframes(cereals_df, pulses_df):
    """
    Merges the two dataframes back into one dataframe and saves it as `merged_data.csv`.

    Args:
        cereals_df (pd.DataFrame): The cereals and tubers dataframe.
        pulses_df (pd.DataFrame): The pulses and nuts dataframe.

    Returns:
        pd.DataFrame: The merged dataframe.
    """
    # Concatenate the two dataframes
    merged_df = pd.concat([cereals_df, pulses_df], ignore_index=True)

    # Save to CSV
    merged_df.to_csv("merged_data.csv", index=False)

    return merged_df

grader.check("q12")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 13:Open the `merged_data.csv` file and select only the `date_new`, `market`, `commodity`, `price`, and `usdprice` columns**
"""

# !mv q13.py tests

def select_columns():
    """
    Opens the `merged_data.csv` file and selects only the `date_new`, `market`, `commodity`, `price`, and `usdprice` columns.

    Returns:
        pd.DataFrame: The dataframe with selected columns.
    """
    # Load the dataset
    df = pd.read_csv("merged_data.csv")

    # Select the required columns
    selected_columns = ["date_new", "market", "commodity", "price", "usdprice"]
    df_selected = df[selected_columns]

    return df_selected

grader.check("q13")

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 14:Group the data by `admin1` (state) and calculate the average `price` and `usdprice` for each state**
"""

# !mv q14.py tests

def calculate_state_avg_prices(df):
    """
    Groups the data by `admin1` (state) and calculates the average `price` and `usdprice` for each state.

    Args:
        df (pd.DataFrame): The input dataframe.

    Returns:
        pd.DataFrame: The dataframe with average prices by state.
    """
    # Group by admin1 (state) and calculate mean price and usdprice
    state_avg_prices = df.groupby("admin1")[["price", "usdprice"]].mean().reset_index()

    return state_avg_prices

grader.check("q14")

state_avg_prices = calculate_state_avg_prices(df)
print(state_avg_prices.head())

"""<!-- END QUESTION -->

<!-- BEGIN QUESTION -->

**Question 15:Identify the top 5 markets with the highest average `usdprice` for `Rice (imported)`.**
"""

# !mv q15.py tests

def identify_top_markets(df):
    """
    Identifies the top 5 markets with the highest average `usdprice` for `Rice (imported)`.

    Args:
        df (pd.DataFrame): The input dataframe.

    Returns:
        pd.Series: A series with the top 5 markets and their average `usdprice`.
    """
    # Filter data for "Rice (imported)"
    rice_df = df[df["commodity"] == "Rice (imported)"]

    # Group by market and calculate the average usdprice
    top_markets = rice_df.groupby("market")["usdprice"].mean().nlargest(5)

    return top_markets

grader.check("q15")

"""<!-- END QUESTION -->

---

To double-check your work, the cell below will rerun all of the autograder tests.
"""

grader.check_all()

"""## Submission

Make sure you have run all cells in your notebook in order before running the cell below, so that all images/graphs appear in the output. The cell below will generate a zip file for you to submit. **Please save before exporting!**

Complete each function according to the provided specifications. Make sure all tests pass.
"""

# Save your notebook first, then run this cell to export your submission.
grader.export(run_tests=True)